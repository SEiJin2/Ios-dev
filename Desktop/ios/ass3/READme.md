# Shopping Cart System — Swift (Classes vs Structs)

## Why `ShoppingCart` is a class
`ShoppingCart` models a single shared, long‑lived entity whose identity matters. Разные части приложения (экраны, сервисы) должны видеть одни и те же изменения корзины. Ссылочная семантика гарантирует, что модификации через любую ссылку отражаются в одном объекте. Кроме того, корзина естественно ведёт состояние (скидочный код, содержимое), а не просто значения.

## Why `Product` and `Order` are structs
`Product` — неизменяемое по смыслу значение, описывающее товар. Ему подходит value‑semantics: копии независимы, легко кешируются/хешируются. `Order` — снимок корзины на момент оформления. Он **immutable**: после создания не должен меняться, чтобы не зависеть от будущих правок корзины. Поэтому обе модели — структуры с value‑семантикой.

## Reference semantics example
Функция `modifyCart(_:)` принимает `ShoppingCart` и добавляет товар. После вызова исходная корзина меняется, потому что передавалась ссылка. Это демонстрирует поведение классов:
```swift
func modifyCart(_ cart: ShoppingCart) { cart.addItem(product: headphones, quantity: 1) }
```
Вместо передачи и возврата копий мы изменяем один и тот же объект с идентичностью.

## Value semantics example
`CartItem` копируется по значению. Если мы присваиваем `item2 = item1` и затем меняем `item2`, `item1` не затрагивается. Это удобно для предсказуемости и локальности изменений.

## Edge cases and decisions
- Валидация цены и количества: использованы **failable init** для `Product` и `CartItem`, а также проверки в методах корзины, чтобы исключить неположительные значения.
- Скидки: простые коды `SAVE10` и `SAVE20`. Неизвестный код даёт ноль скидки.
- Числовая стабильность: тотал не опускается ниже нуля.
- Инкапсуляция: `items` имеют `private(set)` в корзине (через методы).

## What was challenging
Главная задача — чисто разделить обязанности и семантики. Ловушка — попытка сделать корзину структурой: копирование привело бы к неожиданному расхождению состояний между экранами. Ещё один момент — корректная агрегация позиций: при повторном добавлении того же товара мы увеличиваем количество, а не создаём дубли. Наконец, важно было обеспечить иммутабельность заказа и копирование содержимого корзины при создании `Order`.

## How to run
- Создайте Playground или проект Swift и добавьте файлы из `Sources/`.
- Вызовите `runAllTests()` из `Tests.swift` (в Playground он уже вызывается).
- В консоли вы увидите пошаговые проверки: суммы, количество, демонстрации value vs reference, создание заказа и очистка корзины.